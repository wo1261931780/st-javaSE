package wo1261931780.stjavaSE.history.c2stage_20220113.ccc010override;

public class ccc017测试 {
	public static void main(String[] args) {
		ccc015fu x1 = new ccc015fu();
		// 父类中创建对象，然后调用父类中的方法
		// 先把参数传递给父类，然后调用父类的方法
		x1.call("1114父类");
		System.out.println("+++++++++++下面是子类+++++++++++");
		ccc016zi x2 = new ccc016zi();
		// 子类中创建对象，然后调用方法
		// 传递的参数是123，但是子类重写父类的方法
		// 传递给子类，因为子类重写了方法，所以有子类的内容出现
		// 子类中，调用了父类的方法，所以也会显示父类方法的内容
		x2.call("123");
		// 子类中，虽然继承了父类，但是重写后，父类的原方法show会彻底消失，不会执行
	}

	// 如果父类中的方法使用private修饰，
	// 那么该方法无法被访问，进而也就无法被重写
	// 这种情况下，即使方法名相同，子类中的方法也无法添加override，
	// 同时，子类中的同名方法会被认定为新方法
	// 就实际效果来说，还是重写了，只不过无法添加注解而已

	// 不管子类中如何表现，最终是按照override能否定义成功，来判断是否重写
}
